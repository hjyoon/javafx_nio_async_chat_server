/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package javafx_nio_async_chat_server;

import java.io.*;
import java.math.*;
import java.util.*;
import java.util.regex.*;
import java.util.concurrent.*;
import java.text.*;
import java.net.*;
import java.net.http.*;
import java.nio.*;
import java.nio.charset.*;
import java.nio.channels.*;

import com.google.gson.*;

public class App {
    public static void main(String[] args) throws Exception {
        ServerExample server = new ServerExample();
        server.startServer();
    }
}

class ServerExample {
    AsynchronousChannelGroup acg;
    AsynchronousServerSocketChannel assc;

    List<Client> connections = new Vector<Client>();

    void startServer() {
        try {
            acg = AsynchronousChannelGroup.withFixedThreadPool(
                    Runtime.getRuntime().availableProcessors(),
                    Executors.defaultThreadFactory()
                );

            assc = AsynchronousServerSocketChannel.open(acg);

            assc.bind(new InetSocketAddress(5001));
        }
        catch(Exception e) {
            e.printStackTrace();
            if(assc.isOpen()) {
                stopServer();
            }
            return;
        }

        System.out.println("[start server]");

        // accept(A attachment, new CompletionHandler<AsynchronousSocketChannel, ? super A> handler)
        assc.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() {
            @Override
            public void completed(AsynchronousSocketChannel socketChannel, Void attachment) {
                try {
                    Client client = new Client(socketChannel, connections);
                    connections.add(client);
                    
                    System.out.println("[accept connection: " + socketChannel.getRemoteAddress()  + ": " + Thread.currentThread().getName() + "]");
                    System.out.println("[the number of connections: " + connections.size() + "]");

                    assc.accept(null, this);
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, Void attachment) {
                System.out.println("[fail to accept]");
                if(assc.isOpen()) {
                    stopServer();
                }
            }
        });
    }

    void stopServer() {
        try {
            connections.clear();
            if(acg != null && !acg.isShutdown()) {
                System.out.println("[stopServer -> shutdownNow]");
                acg.shutdownNow();
                //assc.close();
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Client {
    AsynchronousSocketChannel asc;
    List<Client> connections;
    String userName;
    Charset charset;

    Client(AsynchronousSocketChannel socketChannel, List<Client> connections) {
        this.asc = socketChannel;
        this.connections = connections;
        charset = Charset.forName("utf-8");
        receive();
    }

    void receive() {
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        // read(ByteBuffer dst, A attachment, new CompletionHandler<Integer, ? super A> handler)
        asc.read(byteBuffer, byteBuffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                try {
                    System.out.println("[process request: " + asc.getRemoteAddress() + ": " + Thread.currentThread().getName() + "]");

                    attachment.flip();
                    Charset charset = Charset.forName("utf-8");
                    String data = charset.decode(attachment).toString(); // .decode() : ByteBuffer -> CharBuffer

                    System.out.println("[success to receive] "  + data);

                    Gson gson = new Gson();
                    MyMessage from = gson.fromJson(data, MyMessage.class);
                    if(from.type.equals("userTalk")) {
                        MyMessage to = new MyMessage("print", userName+"> "+from.data+"\n");
                        //String json = gson.toJson(to);
                        // broadcasting to all
                        for(Client client : connections) {
                            ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                            client.send(byteBuffer);
                        }
                    }
                    else if(from.type.equals("setNickname")) {
                        userName = from.data;

                        MyMessage to = new MyMessage("print", Util.time_now()+" \""+userName+"\" has joined.\n");
                        //String json = gson.toJson(to);
                        for(Client client : connections) {
                            ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                            client.send(byteBuffer);
                        }

                        Thread.sleep(10);

                        to = new MyMessage("newJoin", userName);
                        //json = gson.toJson(to);
                        // broadcasting to all
                        for(Client client : connections) {
                            if(Client.this == client) {
                                continue;
                            }
                            ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                            client.send(byteBuffer);
                        }

                        Thread.sleep(10);

                        String[] users = new String[connections.size()];
                        for(int i=0; i<users.length; i++) {
                            users[i] = connections.get(i).userName;
                        }
                        to = new MyMessage("userList", users);
                        //json = gson.toJson(to);
                        ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                        Client.this.send(byteBuffer);
                    }

                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                    asc.read(byteBuffer, byteBuffer, this);
                }
                catch(Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                try {
                    System.out.println("[read error from client: " + asc.getRemoteAddress() + ": " + Thread.currentThread().getName() + "]");

                    connections.remove(Client.this);
                    asc.close();

                    Gson gson = new Gson();
                    MyMessage to = new MyMessage("userLeave", userName);
                    //String json = gson.toJson(to);
                    for(Client client : connections) {
                        ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                        client.send(byteBuffer);
                    }

                    try {
                        Thread.sleep(10);
                    }
                    catch(Exception e) {
                        e.printStackTrace();
                    }

                    to = new MyMessage("print", Util.time_now()+" \""+userName+"\" has left.\n");
                    //json = gson.toJson(to);
                    for(Client client : connections) {
                        ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                        client.send(byteBuffer);
                    }
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    void send(ByteBuffer bb) {
        //write(ByteBuffer src, A attachment, new CompletionHandler<Integer, ? super A> handler);
        asc.write(bb, null, new CompletionHandler<Integer, Void>() {
            @Override
            public void completed(Integer result, Void attachment) {
                String data = charset.decode(bb).toString();
                System.out.println("[success to send] "  + data);
            }

            @Override
            public void failed(Throwable exc, Void attachment) {
                try {
                    System.out.println("[write error to client: " + asc.getRemoteAddress() + ": " + Thread.currentThread().getName() + "]");

                    connections.remove(Client.this);
                    asc.close();

                    Gson gson = new Gson();
                    MyMessage to = new MyMessage("userLeave", userName);
                    //String json = gson.toJson(to);
                    for(Client client : connections) {
                        ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                        client.send(byteBuffer);
                    }

                    try {
                        Thread.sleep(10);
                    }
                    catch(Exception e) {
                        e.printStackTrace();
                    }

                    to = new MyMessage("print", Util.time_now()+" \""+userName+"\" has left.\n");
                    //json = gson.toJson(to);
                    for(Client client : connections) {
                        ByteBuffer byteBuffer = charset.encode(gson.toJson(to));
                        client.send(byteBuffer);
                    }
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}